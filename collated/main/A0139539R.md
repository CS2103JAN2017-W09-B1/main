# A0139539R
###### \java\seedu\address\logic\commands\ListCommand.java
``` java
package seedu.address.logic.commands;

import java.util.Optional;

/**
 * Lists all persons in the address book to the user.
 */
public class ListCommand extends Command {

    public static final String COMMAND_WORD = "list";

    public static final String MESSAGE_SUCCESS = "Listed all tasks by %1$s.";
    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Lists tasks according to date, priority, title.";

    public static final String COMPARATOR_NAME_DATE = "date";
    public static final String COMPARATOR_NAME_PRIORITY = "priority";
    public static final String COMPARATOR_NAME_TITLE = "title";

    private String comparatorName;

    public ListCommand(Optional<String> comparatorName) {
        this.comparatorName = comparatorName.get();
    }

    @Override
    public CommandResult execute() {
        model.setCurrentComparator(comparatorName);
        model.updateFilteredTaskListToShowAllTasks();
        return new CommandResult(String.format(MESSAGE_SUCCESS, comparatorName));
    }
}
```
###### \java\seedu\address\logic\parser\ListCommandParser.java
``` java
package seedu.address.logic.parser;

import static seedu.address.commons.core.Messages.MESSAGE_INVALID_COMMAND_FORMAT;

import java.util.Optional;

import seedu.address.logic.commands.Command;
import seedu.address.logic.commands.IncorrectCommand;
import seedu.address.logic.commands.ListCommand;

/**
 * Parses input arguments and creates a new ListCommand object
 */
public class ListCommandParser {

    /**
     * Parses the given {@code String} of arguments in the context of the ListCommand
     * and returns an ListCommand object for execution.
     */
    public Command parse(String args) {

        Optional<String> comparatorName = ParserUtil.parseComparatorName(args);
        if (!comparatorName.isPresent()) {
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, ListCommand.MESSAGE_USAGE));
        }

        return new ListCommand(comparatorName);
    }

}
```
###### \java\seedu\address\logic\parser\ParserUtil.java
``` java
    private static final Pattern COMPARATOR_NAME_ARGS_FORMAT = Pattern.compile(
            "(?<comparatorName>("
            + ListCommand.COMPARATOR_NAME_DATE
            + "|"
            + ListCommand.COMPARATOR_NAME_PRIORITY
            + "|"
            + ListCommand.COMPARATOR_NAME_TITLE
            + ")?)"
            );
```
###### \java\seedu\address\logic\parser\ParserUtil.java
``` java
    /**
     * Returns the specified task list name in the {@code command} if it is an alpha-non-numeric string
     * that corresponds to a valid task list name.
     * Returns "invalid" otherwise.
     */
    public static Optional<String> parseComparatorName(String command) {
        final Matcher matcher = COMPARATOR_NAME_ARGS_FORMAT.matcher(command.trim());
        if (!matcher.matches()) {
            return Optional.empty();
        }

        String comparatorName = matcher.group("comparatorName").isEmpty()
                ? "priority" : matcher.group("comparatorName");
        return Optional.of(comparatorName);

    }
```
###### \java\seedu\address\model\ModelManager.java
``` java
    private class NameFloatingTaskQualifier implements Qualifier {
        private Set<String> nameKeyWords;
        private FuzzyFinder fuzzyFinder;

        NameFloatingTaskQualifier(Set<String> nameKeyWords) {
            this.nameKeyWords = nameKeyWords;
            this.fuzzyFinder = new FuzzyFinder();
        }

        @Override
        public boolean run(ReadOnlyTask task) {
            boolean isKeywordPresent = fuzzyFinder.check(task, nameKeyWords);
            boolean isFloatingTask = !task.isCompleted() && task.isFloating();
            return isFloatingTask && isKeywordPresent;
        }

        @Override
        public String toString() {
            return "name=" + String.join(", ", nameKeyWords);
        }
    }

    private class NameNonFloatingTaskQualifier implements Qualifier {
        private Set<String> nameKeyWords;
        private FuzzyFinder fuzzyFinder;

        NameNonFloatingTaskQualifier(Set<String> nameKeyWords) {
            this.nameKeyWords = nameKeyWords;
            this.fuzzyFinder = new FuzzyFinder();
        }

        @Override
        public boolean run(ReadOnlyTask task) {
            boolean isKeywordPresent = fuzzyFinder.check(task, nameKeyWords);
            boolean isNonFloatingTask = !task.isCompleted() && !task.isFloating();
            return isNonFloatingTask && isKeywordPresent;
        }

        @Override
        public String toString() {
            return "name=" + String.join(", ", nameKeyWords);
        }
    }

    private class NameCompletedTaskQualifier implements Qualifier {
        private Set<String> nameKeyWords;
        private FuzzyFinder fuzzyFinder;

        NameCompletedTaskQualifier(Set<String> nameKeyWords) {
            this.nameKeyWords = nameKeyWords;
            this.fuzzyFinder = new FuzzyFinder();
        }

        @Override
        public boolean run(ReadOnlyTask task) {
            boolean isKeywordPresent = fuzzyFinder.check(task, nameKeyWords);
            boolean isCompletedTask = task.isCompleted();
            return isCompletedTask && isKeywordPresent;
        }

        @Override
        public String toString() {
            return "name=" + String.join(", ", nameKeyWords);
        }
    }

    private class FuzzyFinder {

        public boolean check(ReadOnlyTask task, Set<String> nameKeyWords) {
            return nameKeyWords.stream()
                    .filter(keyword -> fuzzyFind(task.getTitle().title.toLowerCase(), keyword.toLowerCase()))
                    .findAny()
                    .isPresent();
        }

        public boolean fuzzyFind(String title, String keyword) {
            return FuzzySearch.ratio(title, keyword) > MATCHING_INDEX;
        }
    }
```
###### \java\seedu\address\model\util\SampleDataUtil.java
``` java
package seedu.address.model.util;

import seedu.address.commons.exceptions.IllegalValueException;
import seedu.address.model.AddressBook;
import seedu.address.model.ReadOnlyAddressBook;
import seedu.address.model.tag.UniqueTagList;
import seedu.address.model.task.Deadline;
import seedu.address.model.task.Instruction;
import seedu.address.model.task.Priority;
import seedu.address.model.task.Task;
import seedu.address.model.task.Title;
import seedu.address.model.task.UniqueTaskList.DuplicateTaskException;

public class SampleDataUtil {

    public static final int SAMPLE_TASKS_LENGTH = 50;

    private static String[] sampleItems = new String[] {
        "apples", "bananas", "coconuts", "durians", "elderberries", "figs", "grapes",
        "honeydews", "imbes", "jackfruits", "kiwis", "lemons", "mangoes", "nectarines",
        "oranges", "pineapples", "quinces", "rambutans", "strawberries", "tangerines",
        "ugnis", "vanilla beans", "watermelons", "xango mangosteens", "yangmeis",
        "zuchinnis", "almonds", "bonbons", "cupcakes", "donuts", "eclairs", "froyos",
        "gingerbreads", "honeycombs", "ice cream sandwiches", "jellybeans", "kitkats",
        "lollipops", "marshmellows", "nougats", "orange tarts", "petit fours",
        "red velvet cakes", "swiss rolls", "tiramisus", "unsalted popcorns",
        "waffles", "xtremes", "yule logs", "zeppoles"};
    private static String[] sampleVerbs = new String[] {"Buy ", "Eat ", "Taste ", "Get "};
    private static String[] sampleDays = new String[] {"Monday", "Tuesday", "Wednesday", "Thursday",
        "Friday", "Saturday", "Sunday", "floating"};
    private static String[] samplePriorities = new String[] {"1", "2", "3", "4", "5", "-1"};

    public static Task[] getSampleTasks() {
        Task[] sampleTasks = new Task[SAMPLE_TASKS_LENGTH];
        for (int i = 0; i < SAMPLE_TASKS_LENGTH; i++) {
            try {
                int itemIndex = i % sampleItems.length;
                int verbIndex = i % sampleVerbs.length;
                int dayIndex = i % sampleDays.length;
                int priorityIndex = i % samplePriorities.length;

                sampleTasks[i] = new Task(new Title(sampleVerbs[verbIndex] + sampleItems[itemIndex]),
                        new Deadline(sampleDays[dayIndex]),
                        new Priority(samplePriorities[priorityIndex]),
                        new Instruction("Cheap offers"),
                        new UniqueTagList("groceries"));
            } catch (IllegalValueException e) {
                throw new AssertionError("sample data cannot be invalid", e);
            }
        }
        return sampleTasks;
    }

    public static ReadOnlyAddressBook getSampleAddressBook() {
        try {
            AddressBook sampleTaskManager = new AddressBook();
            for (Task sampleTask : getSampleTasks()) {
                sampleTaskManager.addTask(sampleTask);
            }
            return sampleTaskManager;
        } catch (DuplicateTaskException e) {
            throw new AssertionError("sample data cannot contain duplicate tasks", e);
        }
    }
}
```
###### \java\seedu\address\model\util\TaskPriorityComparator.java
``` java
package seedu.address.model.util;

import java.util.Comparator;
import java.util.Date;

import seedu.address.model.task.ReadOnlyTask;

public class TaskPriorityComparator implements Comparator<ReadOnlyTask> {
    @Override
    public int compare(ReadOnlyTask firstTask, ReadOnlyTask secondTask) {
        String firstPriority = firstTask.getPriority().value;
        String secondPriority = secondTask.getPriority().value;
        if (firstPriority.compareTo(secondPriority) == 0) {
            Date firstDate = firstTask.getDeadline().toDeadline();
            Date secondDate = secondTask.getDeadline().toDeadline();
            if (firstDate.compareTo(secondDate) == 0) {
                String firstTitle = firstTask.getTitle().title;
                String secondTitle = secondTask.getTitle().title;
                return firstTitle.compareTo(secondTitle);
            }
        }
        return secondPriority.compareTo(firstPriority);
    }
}
```
